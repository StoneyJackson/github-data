# Phase 2: CLI Generator Tool - Detailed Implementation Plan

**Date:** 2025-10-24
**Phase:** 2 of 5 - CLI Entity Generator
**Depends On:** Phase 1 (Core Infrastructure) must be complete
**Estimated Time:** 3-4 hours
**Target Audience:** Engineers with zero entity-registry context

---

## Overview

This phase creates a CLI tool that generates all boilerplate code needed for a new entity. The tool will:
- Accept both command-line arguments and interactive prompts
- Generate entity_config.py, models.py, save_strategy.py, restore_strategy.py
- Validate inputs and check for file conflicts
- Ensure generated code follows conventions exactly

**Success Criteria:**
- Running `python -m src.tools.generate_entity --name comment_attachments --deps issues,comments` generates a complete, valid entity structure
- All generated files follow naming conventions
- Generated code passes linting and type checking
- Manual testing shows entity is auto-discovered by registry

---

## Prerequisites

**Required Knowledge:**
- Basic Python (class definitions, string formatting)
- Command-line argument parsing (argparse)
- Template rendering (Jinja2)
- File I/O operations

**Required Completed Work:**
- Phase 1 must be complete and tested
- `src/entities/base.py` exists with EntityConfig protocol
- `src/entities/registry.py` exists with discovery mechanism
- All Phase 1 tests passing

**Verification Command:**
```bash
# Verify Phase 1 is complete
pytest tests/unit/entities/test_registry.py -v
pytest tests/unit/entities/test_base.py -v
```

---

## Task Breakdown

### Task 1: Create Project Structure for Generator Tool

**Estimated Time:** 15 minutes

**What to do:**
1. Create directory: `src/tools/`
2. Create file: `src/tools/__init__.py` (empty)
3. Create directory: `src/tools/templates/`
4. Create file: `src/tools/templates/__init__.py` (empty)

**Exact commands:**
```bash
mkdir -p src/tools/templates
touch src/tools/__init__.py
touch src/tools/templates/__init__.py
```

**Verification:**
```bash
# Should show the new directories
tree src/tools/
```

**Expected output:**
```
src/tools/
├── __init__.py
└── templates/
    └── __init__.py
```

---

### Task 2: Create Entity Config Template

**Estimated Time:** 20 minutes

**What to do:**
Create a Jinja2 template for `entity_config.py` that accepts these variables:
- `class_name` (e.g., "CommentAttachmentsEntityConfig")
- `entity_name` (e.g., "comment_attachments")
- `env_var` (e.g., "INCLUDE_COMMENT_ATTACHMENTS")
- `default_value` (e.g., "True" or "False")
- `value_type` (e.g., "bool" or "Union[bool, Set[int]]")
- `dependencies` (list of strings, e.g., ["issues", "comments"])
- `description` (string)

**File to create:** `src/tools/templates/entity_config_template.py.j2`

**Complete file contents:**
```python
"""Entity configuration for {{ entity_name }}.

This file was auto-generated by src/tools/generate_entity.py
"""
from typing import Union, Set
from src.entities.base import EntityConfig


class {{ class_name }}(EntityConfig):
    """{{ description }}

    Auto-discovered by naming convention: *EntityConfig
    """

    name = "{{ entity_name }}"
    env_var = "{{ env_var }}"
    default_value = {{ default_value }}
    value_type = {{ value_type }}
    {% if dependencies %}
    dependencies = {{ dependencies }}
    {% else %}
    dependencies = []
    {% endif %}
    description = "{{ description }}"
```

**Verification:**
```bash
# Check file was created
cat src/tools/templates/entity_config_template.py.j2
```

---

### Task 3: Create Models Template

**Estimated Time:** 15 minutes

**What to do:**
Create a Jinja2 template for `models.py` with basic Pydantic model structure.

**File to create:** `src/tools/templates/models_template.py.j2`

**Complete file contents:**
```python
"""Data models for {{ entity_name }}.

This file was auto-generated by src/tools/generate_entity.py
You should customize these models for your specific entity.
"""
from typing import Optional, Any, Dict
from pydantic import BaseModel, Field


class {{ model_class_name }}(BaseModel):
    """Data model for {{ entity_name }}.

    TODO: Add your entity-specific fields here.

    Example fields:
        id: int
        name: str
        created_at: str
        updated_at: str
        custom_field: Optional[str] = None
    """

    # TODO: Replace this placeholder with actual fields
    id: int = Field(..., description="Unique identifier")

    class Config:
        """Pydantic model configuration."""
        frozen = True  # Make instances immutable
```

**Verification:**
```bash
cat src/tools/templates/models_template.py.j2
```

---

### Task 4: Create Save Strategy Template

**Estimated Time:** 20 minutes

**What to do:**
Create a Jinja2 template for `save_strategy.py` with skeleton implementation.

**File to create:** `src/tools/templates/save_strategy_template.py.j2`

**Complete file contents:**
```python
"""Save strategy for {{ entity_name }}.

This file was auto-generated by src/tools/generate_entity.py
You MUST implement the execute() method for your specific entity.
"""
from typing import List
from pathlib import Path
from src.operations.save.base_save_strategy import BaseSaveStrategy
from src.services.github_service import GitHubService
from .models import {{ model_class_name }}


class {{ save_strategy_class }}(BaseSaveStrategy):
    """Save strategy for {{ entity_name }}.

    This strategy handles saving {{ entity_name }} data from GitHub
    to local JSON files.
    """

    def __init__(
        self,
        github_service: GitHubService,
        data_path: Path,
        entity_config: "EntityConfig"
    ):
        """Initialize the save strategy.

        Args:
            github_service: GitHub API service for data fetching
            data_path: Base path for saving data files
            entity_config: Configuration for this entity
        """
        super().__init__(github_service, data_path, entity_config)

    def execute(self) -> None:
        """Execute the save operation for {{ entity_name }}.

        TODO: Implement this method to:
        1. Fetch {{ entity_name }} data from GitHub using self.github_service
        2. Transform data into {{ model_class_name }} instances
        3. Validate data
        4. Save to JSON file using self.save_to_json()

        Example:
            # Fetch data
            raw_data = self.github_service.fetch_{{ entity_name }}()

            # Transform
            models = [{{ model_class_name }}(**item) for item in raw_data]

            # Save
            self.save_to_json(models, "{{ entity_name }}.json")
        """
        raise NotImplementedError(
            "You must implement execute() method for {{ save_strategy_class }}"
        )
```

**Verification:**
```bash
cat src/tools/templates/save_strategy_template.py.j2
```

---

### Task 5: Create Restore Strategy Template

**Estimated Time:** 20 minutes

**What to do:**
Create a Jinja2 template for `restore_strategy.py` with skeleton implementation.

**File to create:** `src/tools/templates/restore_strategy_template.py.j2`

**Complete file contents:**
```python
"""Restore strategy for {{ entity_name }}.

This file was auto-generated by src/tools/generate_entity.py
You MUST implement the execute() method for your specific entity.
"""
from typing import List
from pathlib import Path
from src.operations.restore.base_restore_strategy import BaseRestoreStrategy
from src.services.github_service import GitHubService
from .models import {{ model_class_name }}


class {{ restore_strategy_class }}(BaseRestoreStrategy):
    """Restore strategy for {{ entity_name }}.

    This strategy handles restoring {{ entity_name }} data from local
    JSON files to GitHub.
    """

    def __init__(
        self,
        github_service: GitHubService,
        data_path: Path,
        entity_config: "EntityConfig"
    ):
        """Initialize the restore strategy.

        Args:
            github_service: GitHub API service for data restoration
            data_path: Base path for reading data files
            entity_config: Configuration for this entity
        """
        super().__init__(github_service, data_path, entity_config)

    def execute(self) -> None:
        """Execute the restore operation for {{ entity_name }}.

        TODO: Implement this method to:
        1. Load {{ entity_name }} data from JSON using self.load_from_json()
        2. Validate data
        3. Restore to GitHub using self.github_service
        4. Handle conflicts and errors

        Example:
            # Load data
            models = self.load_from_json("{{ entity_name }}.json", {{ model_class_name }})

            # Restore each item
            for model in models:
                try:
                    self.github_service.create_{{ entity_name }}(model)
                except Exception as e:
                    self.handle_error(model, e)
        """
        raise NotImplementedError(
            "You must implement execute() method for {{ restore_strategy_class }}"
        )
```

**Verification:**
```bash
cat src/tools/templates/restore_strategy_template.py.j2
```

---

### Task 6: Create __init__ Template

**Estimated Time:** 10 minutes

**What to do:**
Create template for entity package __init__.py that exports public API.

**File to create:** `src/tools/templates/init_template.py.j2`

**Complete file contents:**
```python
"""{{ entity_name }} entity package.

This file was auto-generated by src/tools/generate_entity.py
"""
from .entity_config import {{ class_name }}
from .models import {{ model_class_name }}
from .save_strategy import {{ save_strategy_class }}
from .restore_strategy import {{ restore_strategy_class }}

__all__ = [
    "{{ class_name }}",
    "{{ model_class_name }}",
    "{{ save_strategy_class }}",
    "{{ restore_strategy_class }}",
]
```

**Verification:**
```bash
cat src/tools/templates/init_template.py.j2
```

---

### Task 7: Create CLI Generator Script (Part 1: Argument Parsing)

**Estimated Time:** 30 minutes

**What to do:**
Create `src/tools/generate_entity.py` with argument parser and input validation.

**File to create:** `src/tools/generate_entity.py`

**Complete file contents (Part 1):**
```python
"""CLI tool for generating entity boilerplate code.

Usage:
    # Interactive mode
    python -m src.tools.generate_entity

    # Command-line args mode
    python -m src.tools.generate_entity \\
        --name comment_attachments \\
        --type bool \\
        --default true \\
        --deps issues,comments \\
        --description "Save and restore comment attachments"

    # Hybrid mode (some args, prompts for missing)
    python -m src.tools.generate_entity --name comment_attachments
"""
import argparse
import sys
from pathlib import Path
from typing import Optional, List


def parse_arguments() -> argparse.Namespace:
    """Parse command-line arguments.

    Returns:
        Parsed arguments namespace
    """
    parser = argparse.ArgumentParser(
        description="Generate entity boilerplate code",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    parser.add_argument(
        "--name",
        type=str,
        help="Entity name in snake_case (e.g., comment_attachments)"
    )

    parser.add_argument(
        "--type",
        type=str,
        choices=["bool", "set"],
        help="Value type: 'bool' or 'set' (for Set[int])"
    )

    parser.add_argument(
        "--default",
        type=str,
        help="Default value: 'true' or 'false'"
    )

    parser.add_argument(
        "--deps",
        type=str,
        help="Comma-separated dependencies (e.g., 'issues,comments')"
    )

    parser.add_argument(
        "--description",
        type=str,
        help="Entity description"
    )

    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite existing files without prompting"
    )

    return parser.parse_args()


def validate_entity_name(name: str) -> bool:
    """Validate entity name format.

    Args:
        name: Entity name to validate

    Returns:
        True if valid, False otherwise
    """
    # Must be snake_case, lowercase, alphanumeric + underscores
    if not name:
        return False

    if not name.islower():
        return False

    if not all(c.isalnum() or c == '_' for c in name):
        return False

    if name.startswith('_') or name.endswith('_'):
        return False

    return True


def prompt_for_value(
    prompt: str,
    default: Optional[str] = None,
    validator: Optional[callable] = None
) -> str:
    """Prompt user for a value with optional default and validation.

    Args:
        prompt: Prompt message
        default: Default value (shown in brackets)
        validator: Optional validation function

    Returns:
        User input or default value
    """
    if default:
        prompt_text = f"{prompt} [{default}]: "
    else:
        prompt_text = f"{prompt}: "

    while True:
        value = input(prompt_text).strip()

        # Use default if no input
        if not value and default:
            value = default

        # Validate if validator provided
        if validator and not validator(value):
            print(f"Invalid input. Please try again.")
            continue

        return value


def get_entity_name(args: argparse.Namespace) -> str:
    """Get entity name from args or prompt.

    Args:
        args: Parsed command-line arguments

    Returns:
        Valid entity name
    """
    if args.name:
        if not validate_entity_name(args.name):
            print(f"Error: Invalid entity name '{args.name}'")
            print("Entity name must be lowercase snake_case")
            sys.exit(1)
        return args.name

    return prompt_for_value(
        "Entity name (snake_case)",
        validator=validate_entity_name
    )


def get_env_var_name(entity_name: str, args: argparse.Namespace) -> str:
    """Get environment variable name.

    Args:
        entity_name: Entity name in snake_case
        args: Parsed arguments (for future customization)

    Returns:
        Environment variable name (e.g., INCLUDE_COMMENT_ATTACHMENTS)
    """
    # Convention: INCLUDE_{UPPER_SNAKE}
    env_var = f"INCLUDE_{entity_name.upper()}"

    # Show computed value and allow override
    confirmed = prompt_for_value(
        f"Environment variable",
        default=env_var
    )

    return confirmed


def get_value_type(args: argparse.Namespace) -> str:
    """Get value type from args or prompt.

    Args:
        args: Parsed command-line arguments

    Returns:
        'bool' or 'set'
    """
    if args.type:
        return args.type

    type_choice = prompt_for_value(
        "Value type (bool/set)",
        default="bool",
        validator=lambda x: x in ["bool", "set"]
    )

    return type_choice


def get_default_value(args: argparse.Namespace) -> str:
    """Get default value from args or prompt.

    Args:
        args: Parsed command-line arguments

    Returns:
        'true' or 'false'
    """
    if args.default:
        if args.default.lower() not in ["true", "false"]:
            print(f"Error: Default must be 'true' or 'false'")
            sys.exit(1)
        return args.default.lower()

    default_choice = prompt_for_value(
        "Default value (true/false)",
        default="true",
        validator=lambda x: x.lower() in ["true", "false"]
    )

    return default_choice.lower()


def get_dependencies(args: argparse.Namespace) -> List[str]:
    """Get dependencies from args or prompt.

    Args:
        args: Parsed command-line arguments

    Returns:
        List of dependency names
    """
    if args.deps:
        deps = [d.strip() for d in args.deps.split(",")]
        return [d for d in deps if d]  # Filter empty strings

    deps_input = prompt_for_value(
        "Dependencies (comma-separated, or empty)",
        default=""
    )

    if not deps_input:
        return []

    deps = [d.strip() for d in deps_input.split(",")]
    return [d for d in deps if d]


def get_description(args: argparse.Namespace) -> str:
    """Get entity description from args or prompt.

    Args:
        args: Parsed command-line arguments

    Returns:
        Entity description
    """
    if args.description:
        return args.description

    return prompt_for_value(
        "Description",
        default="Entity description"
    )


if __name__ == "__main__":
    # Placeholder - will be completed in Part 2
    args = parse_arguments()

    # Gather all inputs
    entity_name = get_entity_name(args)
    env_var = get_env_var_name(entity_name, args)
    value_type = get_value_type(args)
    default_value = get_default_value(args)
    dependencies = get_dependencies(args)
    description = get_description(args)

    print(f"\\nCollected inputs:")
    print(f"  Entity name: {entity_name}")
    print(f"  Environment variable: {env_var}")
    print(f"  Value type: {value_type}")
    print(f"  Default value: {default_value}")
    print(f"  Dependencies: {dependencies}")
    print(f"  Description: {description}")
    print(f"\\n(File generation not yet implemented)")
```

**Verification:**
```bash
# Test interactive mode
python -m src.tools.generate_entity --name test_entity --type bool --default true --description "Test"

# Should show collected inputs
```

---

### Task 8: Create CLI Generator Script (Part 2: Template Rendering)

**Estimated Time:** 30 minutes

**What to do:**
Add template rendering logic to `generate_entity.py`.

**Updates to:** `src/tools/generate_entity.py`

**Add these imports at the top:**
```python
from jinja2 import Environment, FileSystemLoader
import json
```

**Add these functions before `if __name__ == "__main__"`:**
```python
def snake_to_pascal(snake_str: str) -> str:
    """Convert snake_case to PascalCase.

    Args:
        snake_str: String in snake_case

    Returns:
        String in PascalCase

    Example:
        >>> snake_to_pascal("comment_attachments")
        "CommentAttachments"
    """
    components = snake_str.split('_')
    return ''.join(x.title() for x in components)


def prepare_template_context(
    entity_name: str,
    env_var: str,
    value_type: str,
    default_value: str,
    dependencies: List[str],
    description: str
) -> dict:
    """Prepare context dictionary for template rendering.

    Args:
        entity_name: Entity name in snake_case
        env_var: Environment variable name
        value_type: 'bool' or 'set'
        default_value: 'true' or 'false'
        dependencies: List of dependency names
        description: Entity description

    Returns:
        Context dictionary for Jinja2 templates
    """
    base_name = snake_to_pascal(entity_name)

    # Determine Python type representation
    if value_type == "bool":
        python_type = "bool"
        python_default = "True" if default_value == "true" else "False"
    else:  # set
        python_type = "Union[bool, Set[int]]"
        python_default = "True" if default_value == "true" else "False"

    return {
        "entity_name": entity_name,
        "class_name": f"{base_name}EntityConfig",
        "model_class_name": f"{base_name}",
        "save_strategy_class": f"{base_name}SaveStrategy",
        "restore_strategy_class": f"{base_name}RestoreStrategy",
        "env_var": env_var,
        "default_value": python_default,
        "value_type": python_type,
        "dependencies": dependencies,
        "description": description,
    }


def check_file_conflicts(entity_path: Path, force: bool) -> bool:
    """Check if entity directory already exists.

    Args:
        entity_path: Path to entity directory
        force: If True, skip conflict check

    Returns:
        True if OK to proceed, False otherwise
    """
    if not entity_path.exists():
        return True

    if force:
        print(f"Warning: Overwriting existing entity at {entity_path}")
        return True

    print(f"Error: Entity directory already exists: {entity_path}")
    print(f"Use --force to overwrite")
    return False


def render_templates(context: dict, entity_path: Path) -> None:
    """Render all templates and write to entity directory.

    Args:
        context: Template context dictionary
        entity_path: Path to entity directory
    """
    # Setup Jinja2 environment
    template_dir = Path(__file__).parent / "templates"
    env = Environment(loader=FileSystemLoader(str(template_dir)))

    # Create entity directory
    entity_path.mkdir(parents=True, exist_ok=True)

    # Template mappings: (template_file, output_file)
    templates = [
        ("entity_config_template.py.j2", "entity_config.py"),
        ("models_template.py.j2", "models.py"),
        ("save_strategy_template.py.j2", "save_strategy.py"),
        ("restore_strategy_template.py.j2", "restore_strategy.py"),
        ("init_template.py.j2", "__init__.py"),
    ]

    for template_file, output_file in templates:
        template = env.get_template(template_file)
        rendered = template.render(**context)

        output_path = entity_path / output_file
        output_path.write_text(rendered)
        print(f"  ✓ {output_file}")


def generate_entity_files(
    entity_name: str,
    env_var: str,
    value_type: str,
    default_value: str,
    dependencies: List[str],
    description: str,
    force: bool
) -> None:
    """Generate all entity files from templates.

    Args:
        entity_name: Entity name in snake_case
        env_var: Environment variable name
        value_type: 'bool' or 'set'
        default_value: 'true' or 'false'
        dependencies: List of dependency names
        description: Entity description
        force: Overwrite existing files
    """
    # Determine entity path
    project_root = Path(__file__).parent.parent.parent
    entity_path = project_root / "src" / "entities" / entity_name

    # Check for conflicts
    if not check_file_conflicts(entity_path, force):
        sys.exit(1)

    # Prepare template context
    context = prepare_template_context(
        entity_name,
        env_var,
        value_type,
        default_value,
        dependencies,
        description
    )

    # Render templates
    print(f"\\n✓ Generating entity: {entity_name}")
    print(f"  Path: {entity_path}")
    render_templates(context, entity_path)

    print(f"\\n✓ Entity generated successfully!")
    print(f"\\nNext steps:")
    print(f"  1. Implement save logic in {entity_path}/save_strategy.py")
    print(f"  2. Implement restore logic in {entity_path}/restore_strategy.py")
    print(f"  3. Customize data models in {entity_path}/models.py")
    print(f"  4. Write entity-specific tests")
    print(f"  5. Run: pytest tests/ -v")
```

**Update the `if __name__ == "__main__":` block:**
```python
if __name__ == "__main__":
    args = parse_arguments()

    # Gather all inputs
    entity_name = get_entity_name(args)
    env_var = get_env_var_name(entity_name, args)
    value_type = get_value_type(args)
    default_value = get_default_value(args)
    dependencies = get_dependencies(args)
    description = get_description(args)

    # Generate files
    generate_entity_files(
        entity_name,
        env_var,
        value_type,
        default_value,
        dependencies,
        description,
        args.force
    )
```

**Verification:**
```bash
# Install jinja2 if not already installed
pdm add jinja2

# Test generation
python -m src.tools.generate_entity \\
    --name test_entity \\
    --type bool \\
    --default true \\
    --description "Test entity" \\
    --force

# Verify files were created
tree src/entities/test_entity/
```

---

### Task 9: Add Dependencies to pyproject.toml

**Estimated Time:** 5 minutes

**What to do:**
Add Jinja2 to project dependencies.

**File to edit:** `pyproject.toml`

**Find the dependencies section and add:**
```toml
dependencies = [
    # ... existing dependencies ...
    "jinja2>=3.1.2",
]
```

**Exact edit:**
Look for the `[project]` section and add `jinja2>=3.1.2` to the dependencies list.

**Verification:**
```bash
pdm install
pdm list | grep jinja2
```

---

### Task 10: Write Unit Tests for Generator (Part 1: Helpers)

**Estimated Time:** 30 minutes

**What to do:**
Create comprehensive tests for the CLI generator.

**File to create:** `tests/unit/tools/test_generate_entity.py`

**Complete file contents (Part 1):**
```python
"""Unit tests for entity generator CLI tool."""
import pytest
from pathlib import Path
from unittest.mock import Mock, patch
from src.tools.generate_entity import (
    validate_entity_name,
    snake_to_pascal,
    prepare_template_context,
    check_file_conflicts,
)


@pytest.mark.unit
class TestValidateEntityName:
    """Test entity name validation."""

    def test_valid_snake_case(self):
        """Valid snake_case names should pass."""
        assert validate_entity_name("comment_attachments")
        assert validate_entity_name("issues")
        assert validate_entity_name("pr_review_comments")

    def test_invalid_uppercase(self):
        """Uppercase letters should fail."""
        assert not validate_entity_name("CommentAttachments")
        assert not validate_entity_name("Issues")

    def test_invalid_special_chars(self):
        """Special characters should fail."""
        assert not validate_entity_name("comment-attachments")
        assert not validate_entity_name("comment.attachments")
        assert not validate_entity_name("comment/attachments")

    def test_invalid_leading_underscore(self):
        """Leading underscores should fail."""
        assert not validate_entity_name("_comments")

    def test_invalid_trailing_underscore(self):
        """Trailing underscores should fail."""
        assert not validate_entity_name("comments_")

    def test_empty_string(self):
        """Empty string should fail."""
        assert not validate_entity_name("")


@pytest.mark.unit
class TestSnakeToPascal:
    """Test snake_case to PascalCase conversion."""

    def test_single_word(self):
        """Single word conversion."""
        assert snake_to_pascal("issues") == "Issues"

    def test_multiple_words(self):
        """Multiple word conversion."""
        assert snake_to_pascal("comment_attachments") == "CommentAttachments"
        assert snake_to_pascal("pr_review_comments") == "PrReviewComments"

    def test_preserves_numbers(self):
        """Numbers should be preserved."""
        assert snake_to_pascal("test_123_entity") == "Test123Entity"


@pytest.mark.unit
class TestPrepareTemplateContext:
    """Test template context preparation."""

    def test_bool_type_context(self):
        """Context for bool type entity."""
        context = prepare_template_context(
            entity_name="test_entity",
            env_var="INCLUDE_TEST_ENTITY",
            value_type="bool",
            default_value="true",
            dependencies=["issues"],
            description="Test entity"
        )

        assert context["entity_name"] == "test_entity"
        assert context["class_name"] == "TestEntityEntityConfig"
        assert context["model_class_name"] == "TestEntity"
        assert context["save_strategy_class"] == "TestEntitySaveStrategy"
        assert context["restore_strategy_class"] == "TestEntityRestoreStrategy"
        assert context["env_var"] == "INCLUDE_TEST_ENTITY"
        assert context["default_value"] == "True"
        assert context["value_type"] == "bool"
        assert context["dependencies"] == ["issues"]
        assert context["description"] == "Test entity"

    def test_set_type_context(self):
        """Context for set type entity."""
        context = prepare_template_context(
            entity_name="issues",
            env_var="INCLUDE_ISSUES",
            value_type="set",
            default_value="false",
            dependencies=[],
            description="Issues entity"
        )

        assert context["value_type"] == "Union[bool, Set[int]]"
        assert context["default_value"] == "False"

    def test_no_dependencies(self):
        """Context with no dependencies."""
        context = prepare_template_context(
            entity_name="labels",
            env_var="INCLUDE_LABELS",
            value_type="bool",
            default_value="true",
            dependencies=[],
            description="Labels"
        )

        assert context["dependencies"] == []


@pytest.mark.unit
class TestCheckFileConflicts:
    """Test file conflict detection."""

    def test_no_conflict_if_not_exists(self, tmp_path):
        """Should return True if directory doesn't exist."""
        entity_path = tmp_path / "entities" / "new_entity"
        assert check_file_conflicts(entity_path, force=False)

    def test_conflict_if_exists_without_force(self, tmp_path):
        """Should return False if directory exists and force=False."""
        entity_path = tmp_path / "entities" / "existing_entity"
        entity_path.mkdir(parents=True)

        assert not check_file_conflicts(entity_path, force=False)

    def test_no_conflict_if_exists_with_force(self, tmp_path, capsys):
        """Should return True if directory exists and force=True."""
        entity_path = tmp_path / "entities" / "existing_entity"
        entity_path.mkdir(parents=True)

        assert check_file_conflicts(entity_path, force=True)

        # Check warning was printed
        captured = capsys.readouterr()
        assert "Overwriting" in captured.out
```

**Verification:**
```bash
# Create test directory
mkdir -p tests/unit/tools
touch tests/unit/tools/__init__.py

# Run tests
pytest tests/unit/tools/test_generate_entity.py -v
```

---

### Task 11: Write Unit Tests for Generator (Part 2: Integration)

**Estimated Time:** 30 minutes

**What to do:**
Add integration tests that verify full file generation.

**Add to:** `tests/unit/tools/test_generate_entity.py`

**Append these test classes:**
```python
@pytest.mark.unit
class TestRenderTemplates:
    """Test template rendering."""

    def test_renders_all_files(self, tmp_path):
        """Should render all entity files."""
        from src.tools.generate_entity import render_templates

        context = {
            "entity_name": "test_entity",
            "class_name": "TestEntityEntityConfig",
            "model_class_name": "TestEntity",
            "save_strategy_class": "TestEntitySaveStrategy",
            "restore_strategy_class": "TestEntityRestoreStrategy",
            "env_var": "INCLUDE_TEST_ENTITY",
            "default_value": "True",
            "value_type": "bool",
            "dependencies": ["issues"],
            "description": "Test entity",
        }

        entity_path = tmp_path / "test_entity"
        render_templates(context, entity_path)

        # Verify all files were created
        assert (entity_path / "entity_config.py").exists()
        assert (entity_path / "models.py").exists()
        assert (entity_path / "save_strategy.py").exists()
        assert (entity_path / "restore_strategy.py").exists()
        assert (entity_path / "__init__.py").exists()

    def test_entity_config_contains_correct_values(self, tmp_path):
        """Entity config should contain correct values."""
        from src.tools.generate_entity import render_templates

        context = {
            "entity_name": "comment_attachments",
            "class_name": "CommentAttachmentsEntityConfig",
            "model_class_name": "CommentAttachments",
            "save_strategy_class": "CommentAttachmentsSaveStrategy",
            "restore_strategy_class": "CommentAttachmentsRestoreStrategy",
            "env_var": "INCLUDE_COMMENT_ATTACHMENTS",
            "default_value": "True",
            "value_type": "bool",
            "dependencies": ["issues", "comments"],
            "description": "Comment attachments",
        }

        entity_path = tmp_path / "comment_attachments"
        render_templates(context, entity_path)

        config_content = (entity_path / "entity_config.py").read_text()

        # Verify key content
        assert 'name = "comment_attachments"' in config_content
        assert 'env_var = "INCLUDE_COMMENT_ATTACHMENTS"' in config_content
        assert 'default_value = True' in config_content
        assert 'value_type = bool' in config_content
        assert "dependencies = ['issues', 'comments']" in config_content

    def test_generated_files_are_valid_python(self, tmp_path):
        """Generated files should be valid Python."""
        import ast
        from src.tools.generate_entity import render_templates

        context = {
            "entity_name": "test_entity",
            "class_name": "TestEntityEntityConfig",
            "model_class_name": "TestEntity",
            "save_strategy_class": "TestEntitySaveStrategy",
            "restore_strategy_class": "TestEntityRestoreStrategy",
            "env_var": "INCLUDE_TEST_ENTITY",
            "default_value": "True",
            "value_type": "bool",
            "dependencies": [],
            "description": "Test",
        }

        entity_path = tmp_path / "test_entity"
        render_templates(context, entity_path)

        # Try to parse each file as valid Python
        for py_file in entity_path.glob("*.py"):
            content = py_file.read_text()
            try:
                ast.parse(content)
            except SyntaxError as e:
                pytest.fail(f"Invalid Python syntax in {py_file.name}: {e}")


@pytest.mark.unit
class TestGenerateEntityFiles:
    """Test complete entity file generation."""

    def test_generates_complete_entity_structure(self, tmp_path, monkeypatch):
        """Should generate complete entity structure."""
        from src.tools.generate_entity import generate_entity_files

        # Mock project root to use tmp_path
        monkeypatch.setattr(
            "src.tools.generate_entity.Path.__file__",
            str(tmp_path / "src" / "tools" / "generate_entity.py")
        )

        # Create templates directory
        templates_dir = tmp_path / "src" / "tools" / "templates"
        templates_dir.mkdir(parents=True)

        # Copy actual templates
        import shutil
        actual_templates = Path("src/tools/templates")
        for template_file in actual_templates.glob("*.j2"):
            shutil.copy(template_file, templates_dir)

        # Generate entity
        generate_entity_files(
            entity_name="test_entity",
            env_var="INCLUDE_TEST_ENTITY",
            value_type="bool",
            default_value="true",
            dependencies=["issues"],
            description="Test entity",
            force=False
        )

        # Verify structure
        entity_path = tmp_path / "src" / "entities" / "test_entity"
        assert entity_path.exists()
        assert (entity_path / "entity_config.py").exists()
        assert (entity_path / "models.py").exists()
        assert (entity_path / "save_strategy.py").exists()
        assert (entity_path / "restore_strategy.py").exists()
        assert (entity_path / "__init__.py").exists()
```

**Verification:**
```bash
pytest tests/unit/tools/test_generate_entity.py -v
```

---

### Task 12: Manual End-to-End Testing

**Estimated Time:** 20 minutes

**What to do:**
Manually test the generator tool with various inputs.

**Test cases to run:**

**Test 1: Interactive mode**
```bash
python -m src.tools.generate_entity
# Enter values when prompted:
# Entity name: manual_test_entity
# Environment variable: INCLUDE_MANUAL_TEST_ENTITY
# Value type: bool
# Default value: true
# Dependencies: issues
# Description: Manual test entity
```

**Expected:** Files generated in `src/entities/manual_test_entity/`

**Test 2: Command-line args mode**
```bash
python -m src.tools.generate_entity \\
    --name cli_test_entity \\
    --type bool \\
    --default false \\
    --deps issues,comments \\
    --description "CLI test entity"
```

**Expected:** Files generated in `src/entities/cli_test_entity/`

**Test 3: Conflict detection**
```bash
# Try to regenerate without --force
python -m src.tools.generate_entity \\
    --name cli_test_entity \\
    --type bool \\
    --default true
```

**Expected:** Error message about existing directory

**Test 4: Force overwrite**
```bash
python -m src.tools.generate_entity \\
    --name cli_test_entity \\
    --type bool \\
    --default true \\
    --force
```

**Expected:** Files overwritten with warning

**Verification checklist:**
- [ ] Interactive mode works
- [ ] Command-line args mode works
- [ ] Conflict detection works
- [ ] Force flag works
- [ ] Generated files have correct names
- [ ] Generated files contain correct content
- [ ] Generated files are valid Python (no syntax errors)

**Cleanup:**
```bash
rm -rf src/entities/manual_test_entity
rm -rf src/entities/cli_test_entity
```

---

### Task 13: Test Generated Entity Auto-Discovery

**Estimated Time:** 15 minutes

**What to do:**
Verify that entities generated by the CLI tool are auto-discovered by the registry.

**Prerequisite:** Phase 1 must be complete with working entity discovery.

**Steps:**

1. Generate a test entity:
```bash
python -m src.tools.generate_entity \\
    --name discovery_test \\
    --type bool \\
    --default true \\
    --description "Auto-discovery test entity" \\
    --force
```

2. Create a simple test script:
```bash
cat > test_discovery.py << 'EOF'
"""Test script to verify entity auto-discovery."""
from src.entities.registry import EntityRegistry

# Create registry (should auto-discover entities)
registry = EntityRegistry()

# Check if discovery_test was found
try:
    entity = registry.get_entity("discovery_test")
    print(f"✓ Entity discovered: {entity.config.name}")
    print(f"  Environment variable: {entity.config.env_var}")
    print(f"  Default value: {entity.config.default_value}")
    print(f"  Value type: {entity.config.value_type}")
    print(f"\\n✓ Auto-discovery works!")
except ValueError as e:
    print(f"✗ Entity not discovered: {e}")
    exit(1)
EOF
```

3. Run test:
```bash
python test_discovery.py
```

**Expected output:**
```
✓ Entity discovered: discovery_test
  Environment variable: INCLUDE_DISCOVERY_TEST
  Default value: True
  Value type: <class 'bool'>

✓ Auto-discovery works!
```

**Cleanup:**
```bash
rm -rf src/entities/discovery_test
rm test_discovery.py
```

**Verification:**
- [ ] Generated entity is auto-discovered
- [ ] Entity config values are correct
- [ ] No import errors or exceptions

---

### Task 14: Run Full Test Suite

**Estimated Time:** 10 minutes

**What to do:**
Run all tests to ensure nothing broke.

**Commands:**
```bash
# Run all unit tests (fast)
make test-unit

# Run linting
make lint

# Run type checking
make type-check

# Run formatting check
make format

# All checks (excluding container tests)
make check
```

**Expected results:**
- All tests pass
- No linting errors
- No type checking errors
- Code is properly formatted

**If any failures:**
1. Read error messages carefully
2. Fix issues one at a time
3. Re-run specific failing test
4. Repeat until all pass

---

### Task 15: Documentation

**Estimated Time:** 20 minutes

**What to do:**
Document the CLI generator tool usage.

**File to create:** `docs/cli-generator-guide.md`

**Complete file contents:**
```markdown
# Entity Generator CLI Tool Guide

## Overview

The entity generator CLI tool automates the creation of entity boilerplate code, including:
- Entity configuration class
- Pydantic data models
- Save strategy skeleton
- Restore strategy skeleton
- Package __init__.py

## Usage

### Interactive Mode

Run without arguments to be prompted for each value:

\`\`\`bash
python -m src.tools.generate_entity
\`\`\`

### Command-Line Arguments Mode

Provide all values as arguments:

\`\`\`bash
python -m src.tools.generate_entity \\
    --name comment_attachments \\
    --type bool \\
    --default true \\
    --deps issues,comments \\
    --description "Save and restore comment attachments"
\`\`\`

### Hybrid Mode

Provide some arguments, get prompted for missing values:

\`\`\`bash
python -m src.tools.generate_entity --name comment_attachments
# Prompts for: type, default, deps, description
\`\`\`

## Arguments

| Argument | Description | Example | Required |
|----------|-------------|---------|----------|
| `--name` | Entity name (snake_case) | `comment_attachments` | Yes* |
| `--type` | Value type: `bool` or `set` | `bool` | Yes* |
| `--default` | Default value: `true` or `false` | `true` | Yes* |
| `--deps` | Comma-separated dependencies | `issues,comments` | No |
| `--description` | Entity description | `"Comment attachments"` | Yes* |
| `--force` | Overwrite existing files | N/A (flag) | No |

*Required via argument or prompt

## Generated Files

The tool generates this structure:

\`\`\`
src/entities/{entity_name}/
├── __init__.py              # Public API exports
├── entity_config.py         # EntityConfig implementation
├── models.py                # Pydantic data models (template)
├── save_strategy.py         # Save strategy (skeleton)
└── restore_strategy.py      # Restore strategy (skeleton)
\`\`\`

## Next Steps After Generation

1. **Implement save logic** in `save_strategy.py`:
   - Fetch data from GitHub
   - Transform to Pydantic models
   - Save to JSON

2. **Implement restore logic** in `restore_strategy.py`:
   - Load data from JSON
   - Validate data
   - Restore to GitHub

3. **Customize data models** in `models.py`:
   - Add entity-specific fields
   - Add validation rules

4. **Write tests** for your entity:
   - Unit tests for strategies
   - Integration tests for workflows

5. **Run tests:**
   \`\`\`bash
   pytest tests/ -v
   \`\`\`

## Examples

### Example 1: Simple Boolean Entity

\`\`\`bash
python -m src.tools.generate_entity \\
    --name notifications \\
    --type bool \\
    --default false \\
    --description "Save and restore notifications"
\`\`\`

### Example 2: Entity with Dependencies

\`\`\`bash
python -m src.tools.generate_entity \\
    --name comment_attachments \\
    --type bool \\
    --default true \\
    --deps issues,comments \\
    --description "Save and restore comment attachments"
\`\`\`

### Example 3: Set-Based Entity

\`\`\`bash
python -m src.tools.generate_entity \\
    --name selective_issues \\
    --type set \\
    --default true \\
    --description "Save specific issue numbers"
\`\`\`

## Validation Rules

### Entity Name
- Must be lowercase
- Must use snake_case
- Alphanumeric and underscores only
- Cannot start or end with underscore

### Environment Variable
- Auto-generated as `INCLUDE_{UPPER_SNAKE}`
- Can be customized during generation

### Dependencies
- Must reference existing entity names
- Comma-separated list
- Empty list is valid

## Troubleshooting

### Error: "Invalid entity name"
- Ensure name is lowercase snake_case
- No special characters except underscores
- Example: `comment_attachments` ✓, `CommentAttachments` ✗

### Error: "Entity directory already exists"
- Use `--force` to overwrite
- Or delete the directory manually

### Generated files have syntax errors
- Report as bug
- Check template files in `src/tools/templates/`

### Entity not auto-discovered
- Verify `entity_config.py` exists
- Verify class name ends with `EntityConfig`
- Check for import errors in entity files

## See Also

- [Entity Development Guide](entity-development-guide.md)
- [Phase 2 Implementation Plan](planning/2025-10-24-phase-2-cli-generator-implementation-plan.md)
- [Entity Registry Design](planning/2025-10-24-01-11-entity-registry-system-design-and-implementation-plan.md)
\`\`\`

**Verification:**
```bash
# Check documentation was created
cat docs/cli-generator-guide.md
```

---

## Phase Completion Checklist

Before marking Phase 2 complete, verify:

- [ ] All templates created and tested
- [ ] CLI tool accepts both args and prompts
- [ ] Input validation works correctly
- [ ] File generation creates all expected files
- [ ] Generated files are valid Python
- [ ] Generated files follow naming conventions
- [ ] Conflict detection works
- [ ] Force flag works
- [ ] All unit tests pass
- [ ] Generated entities are auto-discovered
- [ ] Documentation complete
- [ ] Jinja2 dependency added to pyproject.toml
- [ ] `make check` passes
- [ ] Manual testing completed successfully

## Final Verification Commands

```bash
# Run all quality checks
make check

# Test generator with real entity
python -m src.tools.generate_entity \\
    --name verification_test \\
    --type bool \\
    --default true \\
    --deps issues \\
    --description "Final verification test" \\
    --force

# Verify generated code is valid
python -c "from src.entities.verification_test.entity_config import VerificationTestEntityConfig; print('✓ Import successful')"

# Cleanup
rm -rf src/entities/verification_test

# Commit Phase 2
git add .
git commit -s -m "feat: add CLI entity generator tool

- Add Jinja2 templates for entity scaffolding
- Implement generate_entity.py with arg parsing and prompts
- Add input validation and conflict detection
- Generate entity_config, models, and strategy skeletons
- Add comprehensive unit tests
- Document CLI tool usage

Phase 2 of entity registry system complete.

Signed-off-by: Your Name <your.email@example.com>"
```

## Success Criteria

Phase 2 is complete when:

1. ✅ CLI tool generates valid entity structure
2. ✅ Both interactive and args modes work
3. ✅ All generated files follow conventions
4. ✅ Generated entities are auto-discoverable
5. ✅ All tests pass
6. ✅ Documentation complete
7. ✅ Ready to proceed to Phase 3

## Troubleshooting Guide

### Issue: Templates not found
**Solution:** Verify templates are in `src/tools/templates/` and have `.j2` extension

### Issue: Generated files have import errors
**Solution:** Check that base classes exist (Phase 1 must be complete)

### Issue: Entity not discovered
**Solution:** Verify class name ends with `EntityConfig` and inherits from protocol

### Issue: Tests fail
**Solution:** Run individual test to see detailed error, fix incrementally

---

**End of Phase 2 Implementation Plan**
